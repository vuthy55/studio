
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Global Helper Functions ---
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function isAdmin() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // --- Collection Rules ---

    // User Profiles: Users can manage their own profile. Admins can manage any.
    match /users/{userId} {
      allow read, update: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      // Allow user to create their own record during signup
      allow create: if isOwner(userId);

      // Transaction Logs: A user can read and create their own logs. Admins can also read.
      match /transactionLogs/{logId} {
        allow read, create: if isOwner(userId) || isAdmin();
        allow update, delete: if false; // Protect logs from modification
      }

      // Payment History: A user can read their own logs. Admins can also read.
      match /paymentHistory/{paymentId} {
        allow read: if isOwner(userId) || isAdmin();
        allow create, update, delete: if false; // Immutable logs, created by server.
      }

      // Practice History: A user can read and write their own practice history. Admins can read.
      match /practiceHistory/{historyId} {
        allow list, read: if isOwner(userId) || isAdmin();
        allow write: if isOwner(userId);
      }
    }
    
    // Rule for collection group query needed for admin token analytics.
    match /{path=**}/transactionLogs/{logId} {
      allow read: if isAdmin();
    }

    // App Settings: Only admins can read and write application-wide settings.
    match /settings/{settingId} {
      allow read, write: if isAdmin();
    }

    // Financial Ledger: Only admins can read financial records.
    match /financialLedger/{docId} {
      allow read: if isAdmin();
    }

    // Sync Rooms: Handles creation, reading, and updates for rooms.
    match /syncRooms/{roomId} {
      function isInvited() {
        return request.auth != null && request.auth.token.email in resource.data.invitedEmails;
      }
      function isEmcee() {
        return request.auth != null && request.auth.uid in resource.data.emceeUids;
      }
      function isCreator() {
        return request.auth != null && request.auth.uid == resource.data.creatorUid;
      }
      function isOnlyChangingSpeaker() {
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['activeSpeakerUid']);
      }

      allow create: if request.auth != null && request.resource.data.creatorUid == request.auth.uid;
      allow read: if isInvited();
      allow update: if isEmcee() || (isInvited() && isOnlyChangingSpeaker());
      allow delete: if isCreator();

      // Participants sub-collection: Rules for joining and management.
      match /participants/{participantId} {
        function roomData() {
          return get(/databases/$(database)/documents/syncRooms/$(roomId)).data;
        }
        function roomExists() {
          return exists(/databases/$(database)/documents/syncRooms/$(roomId));
        }
        function isInvitedToRoom() {
          return roomExists() && request.auth != null && request.auth.token.email in roomData().invitedEmails;
        }
        function isEmceeInRoom() {
          return roomExists() && request.auth != null && request.auth.uid in roomData().emceeUids;
        }
        function isRoomCreator() {
          return roomExists() && request.auth != null && request.auth.uid == roomData().creatorUid;
        }
        // This function checks if the user is the creator during a batch write.
        function isCreatingOwnParticipantRecord() {
            return request.auth != null && request.auth.uid == participantId &&
                   request.resource.data.uid == request.auth.uid &&
                   getAfter(/databases/$(database)/documents/syncRooms/$(roomId)).data.creatorUid == request.auth.uid;
        }

        allow list, read: if isInvitedToRoom();
        // Allow creation if the user is invited OR if they are creating the room itself.
        allow create: if (request.auth != null && isInvitedToRoom() && request.resource.data.uid == request.auth.uid) || isCreatingOwnParticipantRecord();
        allow update: if isEmceeInRoom() || (request.auth != null && request.auth.uid == participantId);
        // Allow the room creator OR the participant themselves to delete the record.
        allow delete: if isRoomCreator() || (request.auth != null && request.auth.uid == participantId);
      }
      
      // Messages sub-collection: Rules for sending and reading messages.
      match /messages/{messageId} {
          function roomData() {
            return get(/databases/$(database)/documents/syncRooms/$(roomId)).data;
          }
          function roomExists() {
            return exists(/databases/$(database)/documents/syncRooms/$(roomId));
          }
          function isInvitedToRoom() {
              return roomExists() &&
                     request.auth != null &&
                     request.auth.token.email in roomData().invitedEmails;
          }
          function isRoomCreator() {
            return roomExists() && request.auth != null && request.auth.uid == roomData().creatorUid;
          }

          allow list, read: if isInvitedToRoom();
          allow create: if isInvitedToRoom() && request.resource.data.speakerUid == request.auth.uid;
          // Allow the room creator to delete any message.
          allow delete: if isRoomCreator();
      }
    }
  }
}
