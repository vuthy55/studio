rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAdmin() {
      // Safe check for admin role, reusable by all rules.
      // Ensures the user is authenticated and their document exists with role 'admin'.
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // User Profiles: Users can manage their own profile. Admins can manage any.
    match /users/{userId} {
      function isOwner() {
        return request.auth != null && request.auth.uid == userId;
      }
      
      // Allow any authenticated user to read profiles (needed for buddy search).
      // Allow admins to list all users.
      allow read: if request.auth != null;
      allow list: if isAdmin();

      // Allow a user to update their own profile, or an admin to update any profile.
      allow update: if isOwner() || isAdmin();
      
      // Allow a user to create their own user document during signup.
      allow create: if isOwner();

      // Transaction Logs: A user can read and create their own logs.
      match /transactionLogs/{logId} {
        allow read, create: if isOwner() || isAdmin();
        allow update, delete: if false; // Protect logs from modification
      }

      // Payment History: A user can read their own logs. Admins can also read.
      match /paymentHistory/{paymentId} {
        allow read: if isOwner() || isAdmin();
        allow create, update, delete: if false; // Immutable logs, created by server.
      }

      // Practice History: A user can read and write their own practice history. Admins can read.
      match /practiceHistory/{historyId} {
        allow list, read: if isOwner() || isAdmin();
        allow write: if isOwner();
      }

      // Saved Phrases: A user can read and write their own saved phrases. Admins can read.
      match /savedPhrases/{phraseId} {
        allow list, read: if isOwner() || isAdmin();
        allow write: if isOwner();
      }
    }
    
    // --- RULES FOR ADMIN DASHBOARD ---
    
    // Financial Ledger: Only admins can read or create entries.
    match /financialLedger/{ledgerId} {
      allow read, create: if isAdmin();
      allow update, delete: if false;
    }
    
    // Transaction Logs Collection Group: Allow admins to query across all users' logs.
    // This is necessary for the main token ledger view in the admin panel.
    match /{path=**}/transactionLogs/{logId} {
      allow read: if isAdmin();
    }
    
    // Referrals Log: Admins can read the central referrals log. Server actions create.
    match /referrals/{referralId} {
      allow read: if isAdmin();
      allow create, update, delete: if false;
    }
    
    // --- END ADMIN RULES ---

    // App Settings: Only admins can read and write application-wide settings.
    match /settings/{settingId} {
      allow read, write: if isAdmin();
    }

    // Sync Rooms: Handles creation, reading, and updates for rooms.
    match /syncRooms/{roomId} {
      function isInvited() {
        // request.resource is null on read, must use resource
        return request.auth != null && resource.data.invitedEmails.hasAny([request.auth.token.email]);
      }
      function isEmcee() {
        // request.resource is null on read, must use resource
        return request.auth != null && resource.data.emceeEmails.hasAny([request.auth.token.email]);
      }
      function isCreator() {
         // request.resource is null on read, must use resource
        return request.auth != null && request.auth.uid == resource.data.creatorUid;
      }
      function isOnlyChangingSpeaker() {
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['activeSpeakerUid']);
      }

      allow create: if request.auth != null && request.resource.data.creatorUid == request.auth.uid;
      allow read: if isInvited();
      allow update: if isEmcee() || (isInvited() && isOnlyChangingSpeaker());
      allow delete: if isCreator();

      // Participants sub-collection: Rules for joining and management.
      match /participants/{participantId} {
        function roomData() {
          return get(/databases/$(database)/documents/syncRooms/$(roomId)).data;
        }
        function roomExists() {
          return exists(/databases/$(database)/documents/syncRooms/$(roomId));
        }
        function isInvitedToRoom() {
          return roomExists() && request.auth != null && roomData().invitedEmails.hasAny([request.auth.token.email]);
        }
        function isEmceeInRoom() {
          return roomExists() && request.auth != null && roomData().emceeEmails.hasAny([request.auth.token.email]);
        }
        function isRoomCreator() {
          return roomExists() && request.auth != null && request.auth.uid == roomData().creatorUid;
        }
        function isSelf() {
            return request.auth != null && request.auth.uid == participantId;
        }

        allow list, read: if isInvitedToRoom();
        allow create: if isSelf() && request.resource.data.uid == request.auth.uid;
        allow update: if isEmceeInRoom() || isSelf();
        allow delete: if isRoomCreator() || isSelf();
      }
      
      // Messages sub-collection: Rules for sending and reading messages.
      match /messages/{messageId} {
          function isParticipant() {
              return exists(/databases/$(database)/documents/syncRooms/$(roomId)/participants/$(request.auth.uid));
          }
          function isRoomCreator() {
            return exists(/databases/$(database)/documents/syncRooms/$(roomId)) &&
                   request.auth != null &&
                   get(/databases/$(database)/documents/syncRooms/$(roomId)).data.creatorUid == request.auth.uid;
          }

          allow list, read: if isParticipant();
          allow create: if isParticipant() && request.resource.data.speakerUid == request.auth.uid;
          allow delete: if isRoomCreator();
      }
    }
    
    // --- RULES FOR COMMON ROOMS (VIBES) ---
    match /vibes/{vibeId} {
      function isVibeCreator() {
        // Use resource.data for read/get/list, request.resource.data for write
        return request.auth != null && resource.data.creatorId == request.auth.uid;
      }
      function isVibeHost() {
        return request.auth != null && resource.data.hostEmails.hasAny([request.auth.token.email]);
      }
      
      function getVibeData() {
          return get(/databases/$(database)/documents/vibes/$(vibeId)).data;
      }
      
      function isVibeMember() {
          return request.auth != null && getVibeData().invitedEmails.hasAny([request.auth.token.email]);
      }

      // Allow anyone to read the top-level Vibe doc. This is required for the join page to work
      // for new users. The sensitive content is in the subcollections.
      allow read: if true;
      allow create: if request.auth != null;
      allow update: if isVibeCreator() || isVibeHost();
      allow delete: if isVibeCreator();

      // Secure the 'posts' subcollection
      match /posts/{postId} {
        // Allow read if the vibe is public OR if the user is an invited member.
        allow read: if getVibeData().isPublic == true || isVibeMember();
        // Allow create only if the user is an invited member.
        allow create: if isVibeMember();
        // Allow update/delete only by the creator or a host.
        allow update, delete: if isVibeCreator() || isVibeHost();
      }
      
      // Secure the 'parties' (meetups) subcollection
      match /parties/{partyId} {
        // Allow read if the vibe is public OR if the user is an invited member.
        allow read: if getVibeData().isPublic == true || isVibeMember();
        // Allow write access only to hosts
        allow write: if isVibeHost();
      }
    }
    
    // PayPal temporary orders: Only allow creation from server-side action
    match /paypalOrders/{orderId} {
        allow read, write: if false; // Client should not access this at all
    }

    // Notifications: Users can read and update (mark as read) their own notifications.
    match /notifications/{notificationId} {
      allow read, update: if request.auth != null && request.auth.uid == resource.data.userId;
      // Server creates notifications, client can request deletion via server action.
      allow create, delete: if false; 
    }
    
    // Invitations: Users can read invitations they have sent.
    match /invitations/{invitationId} {
      allow read: if request.auth != null && request.auth.uid == resource.data.inviterId;
      // Server creates invitations, client-side reads only.
      allow create, update, delete: if false;
    }
  }
}